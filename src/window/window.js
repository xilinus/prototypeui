/*
Class: UI.Window
  Main class to handle windows inside a web page.

  Example:
    > new UI.Window({ theme: 'bluglighting' }).show()
*/
                               

/*
<div class="STitle">Options</div>
*/

UI.Window = Class.create(UI.Options, {
  // Group: Options
  options: {
    
    // Property: theme
    //   window theme, uses the window manager theme as default
    theme:         null,
    
    // Property: shadowTheme
    //   window shadow theme, uses the window manager one as default
    //   Only useful if <shadow> options is true, see <UI.Shadow> for details
    shadowTheme:   null,
    
    // Property: id
    //   id ot the window, generated by default
    id:            null,
    
    // Property: windowManager
    //   window manager that manages this window,
    //   uses UI.defaultWM as default
    windowManager: null,
    
    top:           null,
    left:          null,
    width:         200,
    height:        300,
    minHeight:     100,
    minWidth:      200,
    maxHeight:     null,
    maxWidth:      null,
    altitude:      "front",
    
    // Property: resizable
    //   true by default
    resizable:     true,
    
    // Property: draggable
    //   true by default
    draggable:     true,
    
    // Property: wired
    //   draw wires around window when dragged, false by default
    wired:         false,

    // Property: show
    //   Function used to show the window, default is Element.show
    show: Element.show,
    
    // Property: hide
    //   Function used to hide the window, default is Element.hide.
    hide: Element.hide,

    // Property: superflousEffects
    //   uses superflous effects when resizing or moving window.
    //   it's true if Scriptaculous' Effect is defined, false otherwise
    superflousEffects: !Object.isUndefined(window.Effect),
    
    // Property: shadow
    //   draw shadow around the window, default is false
    shadow:            false,
    
    // Property: activeOnClick
    //   When set to true, a click on an blurred window content activates it,
    //   default is true
    activeOnClick:     true,

    // Grid
    gridX:  1,
    gridY:  1,
    
    // Buttons and actions (false to disable)
    
    // Property: close
    //   Window method name as string, or false to disable close button
    //   Default is 'destroy'
    close:    'destroy',
    
    // Property: minimize
    //   Window method name as string, or false to disable minimize button
    //   Default is 'toggleFold'
    minimize: 'toggleFold',
    
    // Property: maximize
    //   Window method name as string, or false to disable maximize button
    //   Default is 'toggleMaximize'
    maximize: 'toggleMaximize'
  },
  
  // Group: Attributes
  
  /*
    Property: id
      DOM id of the window's element

    Property: element
      DOM element containing the window

    Property: windowManager
      Window manager that manages the window
    
    Property: content
      Window content element
    
    Property: header
      Window header element
    
    Property: footer
      Window footer element

    Property: visible
      true if window is visible
      
    Property: focused
      true if window is focused

    Property: folded
      true if window is folded

    Property: maximized
      true if window is maximized
  */
  
  /*
    Group: Events   
    List of events fired by a window
  */
  
  /*
    Property: created
      Fired after creating the window
    
    Property: destroyed
      Fired after destroying the window

    Property: showing
      Fired when showing a window

    Property: shown
      Fired after showing effect

    Property: hiding
      Fired when hiding a window

    Property: hidden
      Fired after hiding effect

    Property: focused
      Fired after focusing the window

    Property: blurred
      Fired after bluring the window

    Property: maximized
      Fired after maximizing the window

    Property: restored
      Fired after restoring the window from its maximized state

    Property: fold
      Fired after unfolding the window

    Property: unfold
      Fired after folding the window     
      
    Property: altitude:changed
      Fired when window altitude has changed (z-index)

    Property: size:changed
      Fired when window size has changed
        
    Property: position:changed
      Fired when window position has changed
    
    Property: move:started
      Fired when user has started a moving a window, position:changed are then fired continously
  
    Property: move:ended
      Fired when user has finished moving a window

    Property: resize:started
      Fired when user has started resizing window, size:changed are then fired continuously

    Property: resize:ended
      Fired when user has finished resizing window

  */
 
  // Group: Contructor
  
  /*
    Method: initialize
      Constructor, should not be called directly, it's called by new operator (new Window())
      The window is not open and nothing has been added to the DOM yet
      
    Parameters:                                                                            
      options - (Hash) list of optional parameters  
      
    Returns:
      this
  */
  initialize: function(options) {
    this.setOptions(options);
    this.windowManager = this.options.windowManager || UI.defaultWM;
    this.create();
    this.id = this.element.id;
    this.windowManager.register(this);
    this.render();
    if (this.options.activeOnClick)
      this.overlay.setStyle({ zIndex: this.lastZIndex + 1 }).show();
  },

  /*
    Method: destroy
      Destructor, closes window, cleans up DOM and memory
  */
  destroy: function($super) {
    this.hide();
    if (this.centerOptions)
      Event.stopObserving(this.windowManager.scrollContainer, "scroll", this.centerOptions.handler);
    this.windowManager.unregister(this);
    this.fire('destroyed');
  },
  
  // Group: Event handling
  
  /*
    Method: fire
      Fires a window custom event automatically namespaced in "window:" (see Prototype custom events).
      The memo object contains a "window" property referring to the window.

    Example:
      > UI.Window.addMethods({
      >   iconify: function() {
      >     // ... your iconifying code here ...
      >     this.fire('iconified');
      >     // chain friendly
      >     return this;
      >   }
      > });
      > 
      > document.observe('window:iconified', function(event) {
      >   alert("Window with id " + event.memo.window.id + " has just been iconified");
      > });

    Parameters:
      eventName - an event name
      memo - a memo object

    Returns:
      fired event
  */
  fire: function(eventName, memo) {
    memo = memo || { };
    memo.window = this;
    return (this.savedElement || this.element).fire('window:' + eventName, memo);
  },

   /*
     Method: observe
       Observe a window event with a handler function automatically bound to the window

     Parameters:
       eventName - an event name
       handler - a handler function

     Returns:
       this
  */  
  observe: function(eventName, handler) {
    this.element.observe('window:' + eventName, handler.bind(this));
    return this;
  },
  

  // Group: Actions

  /*
    Method: show
      Opens the window (appends it to the DOM)

    Parameters:
      modal - open the window in a modal mode (default false) 

    Returns:
      this
 */
  show: function(modal) {
    if (this.visible) return this;
    
    this.fire('showing');
    this.effect('show');
    
    if (modal) {
      this.windowManager.startModalSession(this);
      this.modalSession = true;
    }

    this.addElements();
    this.visible = true;

    new PeriodicalExecuter(function(executer) {
      if (!this.element.visible()) return;
      this.fire('shown');
      executer.stop();
    }.bind(this), 0.1);
    
    return this;
  },

  /*
    Method: hide
       Hides the window, (removes it from the DOM)

     Returns:
       this
  */
  hide: function() {
    if (!this.visible) return this;
    
    this.fire('hiding');
    this.effect('hide');
    
    if (this.modalSession) {
      this.windowManager.endModalSession(this);
      this.modalSession = false;
    }
    
    this.windowManager.hide(this);

    new PeriodicalExecuter(function(executer) {
      if (this.element.visible()) return;
      this.visible = false;
      this.element.remove();
      this.fire('hidden');
      executer.stop();
    }.bind(this), 0.1);
    
    return this;
  },
  
  close: function() {
    return this.action('close');
  },

  /*
    Method: activate
      Brings window to the front and sets focus on it
      
     Returns:
       this
  */
  activate: function() {
    return this.bringToFront().focus();
  },
  
  /*
    Method: bringToFront
      Brings window to the front (but does not set focus on it)
      
     Returns:
       this
  */
  bringToFront: function() {
    return this.setAltitude('front');
  },
  
  /*
    Method: sendToBack
      Sends window to the back (without changing its focus)
      
     Returns:
       this
  */
  sendToBack: function() {
    return this.setAltitude('back');
  },

  /*
    Method: focus
      Focuses the window (without bringing window to the front)
      
     Returns:
       this
  */
  focus: function() { 
    if (this.focused) return this;
      
    this.windowManager.focus(this);
    // Hide the overlay that catch events
    this.overlay.hide();
    // Add focused class name
    this.element.addClassName(this.options.theme + '_focused');
    
    this.focused = true;
    this.fire('focused');
    return this;
  },
  
  /*
    Method: blur
      Blurs the window (without changing windows order)
      
     Returns:
       this
  */
  blur: function() {
    if (!this.focused) return this;
      
    this.windowManager.blur(this);
    this.element.removeClassName(this.options.theme + '_focused');

    // Show the overlay to catch events
    if (this.options.activeOnClick)
      this.overlay.setStyle({ zIndex: this.lastZIndex + 1 }).show();

    this.focused = false;
    this.fire('blurred');
    return this;
  },

  /*
    Method: maximize
      Maximizes window inside its viewport (managed by WindowManager)
      Makes window take full size of its viewport

     Returns:
       this
  */
  maximize: function() {
    if (this.maximized) return this;

    // Get bounds has to be before  this.windowManager.maximize for IE!! this.windowManager.maximize remove overflow
    // and it breaks this.getBounds()
    var bounds = this.getBounds();
    if (this.windowManager.maximize(this)) {
      this.disableButton('minimize').setResizable(false).setDraggable(false);

      this.activate();
      this.maximized = true; 
      this.savedArea = bounds;
      var newBounds = Object.extend(this.windowManager.viewport.getDimensions(), { top: 0, left: 0 });
      this[this.options.superflousEffects && !Prototype.Browser.IE ? "morph" : "setBounds"](newBounds);
      this.fire('maximized');
      return this;
    }
  },
  
  /*
    Function: restore
      Restores a maximized window to its initial size

     Returns:
       this
  */
  restore: function() {
    if (!this.maximized) return this;

    if (this.windowManager.restore(this)) {
      this[this.options.superflousEffects  && !Prototype.Browser.IE ? "morph" : "setBounds"](this.savedArea);
      this.enableButton("minimize").setResizable(true).setDraggable(true);
      
      this.maximized = false;
      this.fire('restored');
      return this;
    }
  },
  
  /*
    Function: toggleMaximize
      Maximizes/Restores window inside it's viewport (managed by WindowManager)

     Returns:
       this
  */
  toggleMaximize: function() {
    return this.maximized ? this.restore() : this.maximize();
  },

  /*
    Function: adapt
      Adapts window size to fit its content

     Returns:
       this
  */
  adapt: function() {
    var dimensions = this.content.getScrollDimensions(); 
    if (this.options.superflousEffects)
      this.morph(dimensions, true);
    else
      this.setSize(dimensions.width, dimensions.height, true);
    return this;
  },
  
  /*
    Method: fold
      Folds window content
      
     Returns:
       this
  */
  fold: function() {
    if (!this.folded) {
      var size = this.getSize(true);
      this.folded = true;
      this.savedInnerHeight = size.height;
      
      if (this.options.superflousEffects)
        this.morph({ width: size.width, height: 0 }, true);
      else
        this.setSize(size.width, 0, true);
      
      this.setResizable(false);
      this.fire("fold");
    }
    return this;
  },
  
  /*
    Method: unfold
      Unfolds window content
      
     Returns:
       this
  */
  unfold: function() {
    if (this.folded) {
      var size = this.getSize(true);
      this.folded = false;
      
      if (this.options.superflousEffects)
        this.morph({ width: size.width, height: this.savedInnerHeight }, true);
      else
        this.setSize(size.width, this.savedInnerHeight, true);

      this.setResizable(true);
      this.fire("unfold");
    }
    return this;
  },
  
  /*
    Method: toggleFold
      Folds/Unfolds window content
      
     Returns:
       this
  */
  toggleFold: function() {
    return this.folded ? this.unfold() : this.fold();
  },

  /*
    Method: setHeader
      Sets window header, equivalent to this.header.update(...) but allows chaining
      
     Returns:
       this
  */
  setHeader: function(header) {
    this.header.update(header);
    return this;
  },
  
  /*
    Method: setContent
      Sets window content, equivalent to this.content.update(...) but allows chaining
      
     Returns:
       this
  */  
  setContent: function(content) {
    this.content.update(content);
    return this;
  },
  
  /*
    Method: setFooter
      Sets window footer, equivalent to this.footer.update(...) but allows chaining
      
     Returns:
       this
  */
  setFooter: function(footer) {
    this.footer.update(footer);
    return this;
  },
      
  /*
    Method: setAjaxContent
      Sets window content using Ajax request
      
     Parameters:
        url - Ajax URL 
        options - Ajax Updater options (see http://prototypejs.org/api/ajax/options and
          http://prototypejs.org/api/ajax/updater)

     Returns:
       this
  */
  setAjaxContent: function(url, options) {
    if (!options)
      options = {};
      
    // bind all callbacks to the window
    Object.keys(options).each(function(name) {
      if (Object.isFunction(options[name]))
        options[name] = options[name].bind(this);
    }, this);

    var onComplete = options.onComplete;
    options.onComplete = (function(response, json) {
      this.setContent(response.responseText);
      if (Object.isFunction(onComplete)) onComplete(response, json);
    }).bind(this);

    new Ajax.Request(url, options);
    return this;
  },

  // Group: Size and Position
  
  /*
    Method: getPosition
      Returns top/left position of a window (in pixels)
      
     Returns:
       an Hash {top:, left:}
  */
  getPosition: function() {  
    return { left: this.options.left, top: this.options.top };
  },

  /*
    Method: setPosition
      Sets top/left position of a window (in pixels)
      
    Parameters
      top:  top position in pixel
      left: left position in pixel
      
    Returns:
      this
  */
  setPosition: function(top, left) {  
    var pos = this.computePosition(top, left);  
    this.options.top  = pos.top;
    this.options.left = pos.left;   
    
    var elementStyle  = this.element.style;
    elementStyle.top  = pos.top + 'px';
    elementStyle.left = pos.left + 'px';
    
    this.fire('position:changed');
    return this;
  },
  
  /*
    Method: center
      Centers the window within its viewport
      
    Returns:
      this
  */
  center: function(options) {
    var size          = this.getSize(),
        windowManager = this.windowManager,
        viewport      = windowManager.viewport;
        viewportArea  = viewport.getDimensions(),
        offset        = viewport.getScrollOffset();
    
    if (options && options.auto) {
      this.centerOptions = Object.extend({ handler: this.recenter.bind(this) }, options); 
      Event.observe(this.windowManager.scrollContainer,"scroll", this.centerOptions.handler);  
      Event.observe(window,"resize", this.centerOptions.handler);
    }
    
    options = Object.extend({
      top:  (viewportArea.height - size.height) / 2,
      left: (viewportArea.width  - size.width)  / 2
    }, options || {});
    
    return this.setPosition(options.top + offset.top, options.left + offset.left);
  },

  /*
    Method: getSize
      Returns window width/height dimensions (in pixels)
    
    Parameters  
      innerSize: returns content size if true, window size if false (defaults to false)
      
    Returns:
      Hash {width:, height:}
  */
  getSize: function(innerSize) {
    if (innerSize) 
      return { width:  this.options.width  - this.borderSize.width, 
               height: this.options.height - this.borderSize.height };
    else
      return { width: this.options.width, height: this.options.height };
  },
  
  /*
    Method: setSize
      Sets window width/height dimensions (in pixels), fires size:changed
      
    Parameters
      width:  width (in pixels)
      height: height (in pixels)
      innerSize: if true change set content size, else set window size (defaults to false)
      
    Returns:
      this
  */
  setSize: function(width, height, innerSize) {
    var size = this.computeSize(width, height, innerSize);
    var elementStyle = this.element.style, contentStyle = this.content.style;

    this.options.width  = size.outerWidth;
    this.options.height = size.outerHeight;

    elementStyle.width = size.outerWidth + "px", elementStyle.height = size.outerHeight + "px";    
    contentStyle.width = size.innerWidth + "px", contentStyle.height = size.innerHeight + "px";
    this.overlay.style.height = size.innerHeight + "px";
    
    this.fire('size:changed');
 	  return this;
  },

  /*
    Method: getBounds
      Returns window bounds (in pixels)
    
    Parameters  
      innerSize: returns content size if true, window size otherwise
      
    Returns:
      an Hash {top:, left:, width:, height:}
  */
  getBounds: function(innerSize) {
    return Object.extend(this.getPosition(), this.getSize(innerSize));
  },
  
  /*
    Method: setBounds
      Sets window bounds (in pixels), fires position:changed and size:changed
    
    Parameters  
      bounds: Hash {top:, left:, width:, height:} where all values are optional
      innerSize: sets content size if true, window size otherwise
      
    Returns:
      Hash {top:, left:, width:, height:}
  */
  setBounds: function(bounds, innerSize) {
    return this.setPosition(bounds.top, bounds.left)
               .setSize(bounds.width, bounds.height, innerSize);
  },
  
  morph: function(bounds, innerSize) {       
    bounds = Object.extend(this.getBounds(innerSize), bounds || {});
    
    if (this.centerOptions && this.centerOptions.auto)  
       bounds = Object.extend(bounds, this.computeRecenter(bounds));

    if (innerSize) {
      bounds.width  += this.borderSize.width;
      bounds.height += this.borderSize.height;
    }
    
    this.animating = true;
    
    new UI.Window.Effects.Morph(this, bounds, { 
      duration: 0.5, 
      afterFinish: function() { this.animating = false }.bind(this)
    });
    
    Object.extend(this.options, bounds);
    
    return this;
  },
  
  /*
    Method: getAltitude
      Returns window altitude, an integer between 0 and the number of windows,
      the higher the altitude number - the higher the window position.
  */
  getAltitude: function() {
    return this.windowManager.getAltitude(this);
  },

  /*
    Method: setAltitude
      Sets window altitude, fires 'altitude:changed' if altitude was changed
  */
  setAltitude: function(altitude) {
    if (this.windowManager.setAltitude(this, altitude))
      this.fire('altitude:changed');
    return this;
  },
  
  /*
    Method: setResizable
      TODO
  */       
  setResizable: function(resizable) {
    this.options.resizable = resizable;
    
    var toggleClassName = (resizable ? 'add' : 'remove') + 'ClassName';
    
    this.element[toggleClassName]('resizable')
      .select('div:[class*=_sizer]').invoke(resizable ? 'show' : 'hide');
    if (resizable) 
      this.createResizeHandles();

    this.element.select('div.se').first()[toggleClassName]('se_resize_handle');
    
    return this;
  },
  
  /*
    Method: setDraggable
      TODO
  */
  setDraggable: function(draggable) {
    this.options.draggable = draggable;
    this.element[(draggable ? 'add' : 'remove') + 'ClassName']('draggable');
    return this;
  },

  // Group: Theme
  /*
    Method: getTheme
      Returns window theme name
  */
  getTheme: function() {
    return this.options.theme || this.windowManager.getTheme();
  },
  
  /*
    Method: setTheme
      Sets window theme
  */
  setTheme: function(theme, windowManagerTheme) {
    this.element.removeClassName(this.getTheme()).addClassName(theme);
    // window has it's own theme
    if (!windowManagerTheme)
      this.options.theme = theme;
    
    return this;
  },
  
  /*
    Method: getShadowTheme
      Returns shadow theme name
  */
  getShadowTheme: function() {
    return this.options.shadowTheme || this.windowManager.getShadowTheme();
  }
});

UI.Window.addMethods(UI.Window.Buttons);
UI.Window.addMethods(UI.Window.Shadow);
UI.Window.optionsAccessor($w(" minWidth minHeight maxWidth maxHeight gridX gridY altitude "));